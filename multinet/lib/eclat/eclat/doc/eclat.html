<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- ===================================================================
  File    : eclat.html
  Contents: Description of Eclat program
  Author  : Christian Borgelt
==================================================================== -->
<html>
<head>
<title>Eclat Documentation</title>

<style type="text/css">
body {
  min-width:   480px;
  background:  white;
  color:       black;
  font-family: sans-serif;
  font-size:   10pt;
}
tt {
  font-family: courier;
  font-size:   10pt;
}
img {
  border:      0px;
}
</style>
</head>

<!-- =============================================================== -->

<body>
<h1><a name="top">Eclat</a></h1>

<h3>Find Frequent Item Sets with the Eclat Algorithm</h3>

<p>Note: This documentation refers to Eclat version 5.0
and may not be compatible with other versions.<br>
Call <tt>eclat</tt> without any options or arguments
to check the actually supported options.</p>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3>Contents</h3>

<ul style="list-style-type:disc">
<li><a href="#intro">Introduction</a></li>
<li><a href="#notions">Basic Notions</a>
    <ul style="list-style-type:circle">
    <li><a href="#items">Items and Transactions</a></li>
    <li><a href="#suppset">Support of an Item Set</a></li>
    </ul></li>
<li><a href="#target">Target Types</a>
    <ul style="list-style-type:circle">
    <li><a href="#sets">Frequent Item Sets</a></li>
    <li><a href="#closed">Closed Item Sets</a></li>
    <li><a href="#maximal">Maximal Item Sets</a></li>
    <li><a href="#generator">Generators/Free Item Sets</a></li>
    </ul></li>
<li><a href="#invoke">Program Invocation</a></li>
<li><a href="#options">Program Options</a></li>
<li><a href="#input">Input Format</a>
    <ul style="list-style-type:circle">
    <li><a href="#transin">Format of the Transactions File</a></li>
    <li><a href="#selin">Format of the Item Selection File</a></li>
    </ul></li>
<li><a href="#output">Output Format</a>
    <ul style="list-style-type:circle">
    <li><a href="#setout">Format of Frequent Item Sets</a></li>
    <li><a href="#pspout">Format of a Pattern Spectrum</a></li>
    </ul></li>
<li><a href="#license">License</a></li>
<li><a href="#download">Download</a></li>
<li><a href="#contact">Contact</a></li>
<li><a href="#refs">References</a></li>
</ul>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="intro">Introduction</a></h3>

<p>Eclat is a program for frequent item set mining, a data mining
method that was originally developed for market basket analysis.
Frequent item set mining aims at finding regularities in the shopping
behavior of the customers of supermarkets, mail-order companies and
online shops. In particular, it tries to identify sets of products
that are frequently bought together. Once identified, such sets of
associated products may be used to optimize the organization of the
offered products on the shelves of a supermarket or the pages of a
mail-order catalog or web shop, may give hints which products may
conveniently be bundled, or may allow to suggest other products to
customers. However, frequent item set mining may be used for a much
wider variety of tasks, which share that one is interested in finding
regularities between (nominal) variables in a given data set. For an
overview of frequent item set mining in general and several specific
algorithms (including Eclat), see the survey
<a href="#Borgelt_2012">[Borgelt 2012]</a>.</p>

<p>This page describes the Eclat implementation that I have been
developing and improving since 2002. This implementation covers the
basic scheme as developed in
<a href="#Zaki_et_al_1997">[Zaki <i>et al.</i> 1997]</a>,
which carries out a depth first search on the subset lattice and
determines the support of item sets by intersecting transaction lists.
It also supports diffsets
<a href="#Zaki_and_Gouda_2003">[Zaki and Gouda 2003]</a>
and several other algorithm variants, including certain variants
of LCM (Linear-time Closed itemset Miner)
<a href="#Uno_et_al_2003">[Uno <i>et al.</i> 2003]</a>,
<a href="#Uno_et_al_2004">[Uno <i>et al.</i> 2004]</a>,
<a href="#Uno_et_al_2005">[Uno <i>et al.</i> 2005]</a>, which
employs an occurrence deliver scheme to determine the support
of item sets.</p>

<p>Note that the current version of this program can only find
frequent item sets, <i>not</i> association rules.</p>

<p>Enjoy,<br>
<a href="http://www.borgelt.net">
Christian Borgelt</a></p>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="notions">Basic Notions</a></h3>

<p>This section briefly introduces some basic notions needed
to talk about frequent item sets. These notions are <i>item</i>,
<i>transaction</i>, <i>support</i> and <i>frequent</i>, <i>closed</i>
and <i>maximal item set</i>. For a more extensive coverage, consult
the survey <a href="#Borgelt_2012">[Borgelt 2012]</a>.</p>

<!-- =============================================================== -->
<hr>

<h4><a name="items">Items and Transactions</a></h4>

<p>On an abstract level, the input to frequent item set mining
consists of a bag or multiset of <i>transactions</i> that are defined
over a set of <i>items</i>, sometimes called the <i>item base</i>.
These items may be products, special equipment items, service options
etc. For an abstract treatment it suffices that items have an identity,
that is, it is possible to distinguish one item from another. The item
base is the set of all considered items, for example, the set of all
products that are sold by a given supermarket, mail-order company or
online shop. Any subset of the item base is called an
<i>item set</i>.</p>

<p>A transaction is simply an item set and it represents, for example,
the set of products bought by a customer. Since two or more customers
may, in principle, buy the exact same set of products, we cannot model
the whole of all "shopping baskets" or "shopping carts" (bought, say,
in a given week) as a <i>set</i> of transactions, since in a set each
element is unique. There are several solutions to this problem: one may,
for example, model the whole of all transactions as a bag or multiset
(a generalization of a set, which allows for multiple occurrences of
the same element) or as a vector (where elements at different positions
may be the same, but are still distinguished by their position), or by
extending each transaction with a unique <i>transaction identifier</i>
(or <i>tid</i> for short; note that the position of a transaction in
a vector representation is an implicit transaction identifier). Still
another possibility consists in using a standard <i>set</i> of (unique)
transactions and assigning to each of them an occurrence counter. Here
I use the bag/multiset terminology, even though an occasional "set of
transactions" may have slipped through. (This should always be read
as "bag/multiset of transactions".)</p>

<p>Note that the item base (the set of all considered items) is often
not given explicitly, but only implicitly as the union of all given
transactions. This is also the case for my Eclat program, which by
default only takes a transaction file as input. However, it is also
possible to specify the item base explicitly with an optional item
selection file (option <tt>-R</tT>; discussed in <a href="#selin">this
section</a>). This can be useful, for example, if one wants to restrict
the analysis to a subset of all items.</p>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<hr>

<h4><a name="suppset">Support of an Item Set</a></h4>

<p>Let S be an item set and T the bag/multiset of all transactions
under consideration. Then the <i>absolute support</i> (or simply the
<i>support</i>) of the item set S is the number of transactions in T
that contain S. Likewise, the <i>relative support</i> of S is the
fraction (or percentage) of the transactions in T which contain S.</p>

<p>More formally, let S be an item set and
U&nbsp;=&nbsp;{&nbsp;X&isin;T&nbsp;|&nbsp;S&sube;t&nbsp;}
the bag/multiset of all transactions in T that have S as a subset
(i.e. contain all of the items in S and possibly some others). Then</p>

<p>supp<sub>abs</sub>(S)&nbsp;=&nbsp;|U|
&nbsp;=&nbsp;|{&nbsp;X&isin;T&nbsp;|&nbsp;S&sube;t&nbsp;}|</p>

<p>is the absolute support of S and</p>

<p>supp<sub>rel</sub>(S)&nbsp;=&nbsp;(|U|&nbsp;/&nbsp;|T|)&nbsp;*100%</p>

<p>is the relative support of S. Here |U| and |T| are the number of
elements in U and T, respectively.</p>

<p>An important insight is that support (regardless of whether it is
stated in an absolute or relative manner) is <i>anti-monotone</i>,
that is</p>

<p>&forall; I, J: (J &sube; I) &rArr; (supp(J) &ge; supp(I)).</p>

<p>That is, if an item set is enlarged by adding one or more items,
its support cannot increase.</p>

<p>In a supermarket setting, the item set S may be a set like
S&nbsp;=&nbsp;{&nbsp;bread, wine, cheese&nbsp;} and T may
be the bag/multiset of all "baskets" or "carts" of products bought by
the customers of a supermarket &ndash; in a given week if you like.
U is the bag/multiset of all transactions in T that contain all items
in S (and maybe also some other items). For example, if a customer
buys the set X&nbsp;=&nbsp;{&nbsp;milk, bread, apples, wine, sausages,
cheese, onions, potatoes&nbsp;}, then S is obviously a subset of X,
hence X is in U. If there are 318 customers, each giving rise to one
transaction, and 242 of these customers bought such a set X or a
similar one that contains S, while the other customers bought sets
of products that lacked at least one of the items in S, then
supp<sub>abs</sub>(S)&nbsp;=&nbsp;242 and
supp<sub>rel</sub>(S)&nbsp;=&nbsp;242/318&nbsp;=&nbsp;76.1%.</p>

<p>The goal of frequent item set mining is to find all item sets
(that is, all subsets of the item base) that occur in the given
bag/multiset of transactions with at least a user-specified
<i>minimum support</i> supp<sub>min</sub>. Such item sets are
called <i>frequent item sets</i>.</p>

<p>Since support is anti-monotone, it follows immediately that</p>

<p>&forall; I, J: (supp(I) &lt; supp<sub>min</sub> &and; J &supe; I)
&rArr; (supp(J) &lt; supp<sub>min</sub>).</p>

<p>This relationship is called the <i>apriori property</i>, which
allows to prune the search for frequent item sets effectively:
<i>no supersets of an infrequent item set can be frequent</i> and
thus need not be visited in the search.</p>

<p>The default value for the minimum support in my Eclat program is
10% (the percentage indicates implicitly that it refers to relative
support). This value can be changed with the option <tt>-s</tt>.
Note that the argument to this option is interpreted as a percentage
if it is positive, but if it is negative, it is interpreted as an
absolute number (number of transactions) rather than a percentage.
That is, <tt>-s20</tt> means a minimum <i>relative</i> support of
20%, while <tt>-s-20</tt> means a minimum <i>absolute</i> support
of 20 transactions.</p>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="target">Target Types</a></h3>

<p>An annoying problem in frequent item set mining is that the number of
frequent item sets is often huge and thus the output can easily exceed
the size of the transaction database to mine. In order to mitigate this
problem, several restrictions of the set of frequent item sets have been
suggested. These restrictions are covered by the target type.</p>

<p>The target type, which can be selected via the option <tt>-t</tt>,
is either frequent item sets (default, option <tt>-ts</tt>),
closed item sets (option <tt>-tc</tt>), maximal item sets
(option <tt>-tm</tt>), or generators (also called free item sets,
option <tt>-tg</tt>).</p>

<p>More detailed information about the different target types of
frequent item set mining can be found in the survey
<a href="#Borgelt_2012">[Borgelt 2012]</a>.</p>

<!-- =============================================================== -->
<hr>

<h4><a name="sets">Frequent Item Sets (default, option -ts)</a></h4>

<p>Often one only wants to find frequent item sets. That is, one wants
to find all item sets with a support exceeding a certain threshold,
the so-called <i>minimum support</i>. For my Eclat program this is
the default operation mode. However, this mode can also be selected
explicitly with the option <tt>-ts</tt>.</p>

<!-- =============================================================== -->
<hr>

<h4><a name="closed">Closed Item Sets (option -tc)</a></h4>

<p>A frequent item set is called <i>closed</i> if no superset has
the same support (or, in other words, if all supersets have a lower
support). Formally, an item set I is called closed iff</p>

<p>&forall; J &sup; I: supp(J) &lt; supp(I).</p>

<p>If the option <tt>-tc</tt> is given, the found frequent item sets
are subsequently filtered and only the closed item sets are
reported.</p>

<!-- =============================================================== -->
<hr>

<h4><a name="maximal">Maximal Item Sets (option -tm)</a></h4>

<p>A frequent item set is called <i>maximal</i> if no superset is
frequent, that is, has a support reaching or exceeding the minimum
support. Formally, an item set I is called maximal iff</p>

<p>&forall; J &sup; I: supp(J) &lt; supp<sub>min.</sub></p>

<p>If the option <tt>-tm</tt> is given, the found frequent item sets are
subsequently filtered and only the maximal item sets are reported.</p>

<!-- =============================================================== -->
<hr>

<h4><a name="generator">Generators/Free Item Sets (option -tg)</a></h4>

<p>A frequent item set is called a <i>generator</i> or <i>free</i>
if no subset has the same support (or, in other words, if all subsets
have a larger support). Formally, an item set I is called a generator
iff</p>

<p>&forall; J &sub; I: supp(J) &gt; supp(I)</p>

<p>If the option <tt>-tg</tt> is given, the found frequent item sets
are subsequently filtered and only the generators / free item sets
are reported.</p>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="invoke">Program Invocation</a></h3>

<p>My Eclat implementation is a command line program that has to be
called in a terminal or command window or from a shell script. If
double-clicked in a file manager (e.g. in Microsoft Windows), it merely
prints a usage message to a terminal/command window that is briefly
opened and immediately closed again. This does not mean that the
program does not work. In order to run the program, open a
terminal/command window, change directory to where you stored
the program, and then type an invocation command.</p>

<p>The general syntax of the program invocation is</p>

<p><tt>eclat [options] infile [outfile]</tt></p>

<p>The first argument <tt>infile</tt>, which is mandatory, is the name
of a file that contains the transactions to analyze. The format of
this file is described in <a href="#transin">this section</a>. If
instead of a file name a single minus sign "<tt>-</tt>" or an empty
string <tt>""</tt> is given, the input is read from standard input
rather than from a file.</p>

<p>The second argument <tt>outfile</tt>, which is optional (as
indicated by the brackets), is the name of a file to which the found
frequent item sets are to be written. That it is optional is useful
for benchmark tests, where the time it takes to write the output to
a file can conceal the actual search time, or if only a pattern
spectrum (number of found frequent item sets collected by size and
(absolute) support; option <tt>-P</tt>) is to be found. The format
in which frequent item sets are written to the output file is described
in <a href="#setout">this section</a>. If instead of a file name a
single minus sign "<tt>-</tt>" or an empty string <tt>""</tt> is
given, the output is written to standard output rather than to a
file.</p>

<p>In addition to the input and output file several options can be
given, all of which consist of a minus sign and a single letter.
The full list of options can be found in the
<a href="#options">next section</a>.</p>

<p>Some options take a parameter. For example, the option <tt>-s</tt>,
with which the minimum support is specified, takes a number as a
parameter, which must follow the letter <tt>s</tt> without any
separating space. A space between the option character and its
parameter is only allowed if the parameter is a string, for example,
a file name. (However, even in this case the parameter may follow
the option letter directly.) If the parameter is a number or a
single letter, it must follow the option letter directly.</p>

<p>Options may be combined. For example,</p>

<p><tt>eclat -s10m2n5 input output</tt></p>

<p>means that the minimum support is 10% (option <tt>-s</tt>),
the minimum number of items in an item set is 2 (option <tt>-m</tt>)
and the maximum number of items in an item set is 5
(option <tt>-n</tt>).</p>

<p>Options may be specified
anywhere on the command line, that is, before the input file name,
in between the input and output file names, or after the output
file name.</p>

<p>If an option is given more than once, the last statement counts.
That is, with</p>

<p><tt>eclat -s10 -s20 input output</tt></p>

<p>the minimum support is 20%, as the <tt>-s10</tt> is overwritten
by the following <tt>-s20</tt>.</p>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="options">Program Options</a></h3>

<p>My Eclat implementation supports the following options<br>
(a <tt>#</tt> after the option letter means that the option
takes a parameter):</p>

<table border=1 cellpadding=2 cellspacing=0>
<tr><th>option</th><th>meaning</th><th>default</th></tr>
<tr><td valign="top"><tt>-t#</tt></td>
    <td>target type<br>
        <tt>s</tt>: frequent item sets<br>
        <tt>c</tt>: closed (frequent) item sets<br>
        <tt>m</tt>: maximal (frequent) item sets<br>
        <tt>g</tt>: (frequent) generators<br>
        <tt>r</tt>: association rules</td>
    <td valign="top"><tt>s</tt></td></tr>
<tr><td valign="top"><tt>-m#</tt></td>
    <td>minimum number of items per item set/association rule</td>
    <td valign="top">1</td></tr>
<tr><td valign="top"><tt>-n#</tt></td>
    <td>maximum number of items per item set/association rule</td>
    <td valign="top">no&nbsp;limit</td></tr>
<tr><td valign="top"><tt>-s#</tt></td>
    <td>minimum support of an item set<br>
        positive: percentage of transactions<br>
        negative: absolute number of transactions</td>
    <td valign="top">10</td></tr>
<tr><td valign="top"><tt>-S#</tt></td>
    <td>maximum support of an item set<br>
        positive: percentage of transactions<br>
        negative: absolute number of transactions</td>
    <td valign="top">100</td></tr>
<tr><td valign="top"><tt>-o</tt></td>
    <td>use original definition of the support of a rule (body & head)</td>
    <td></td></tr>
<tr><td valign="top"><tt>-c#</tt></td>
    <td>minimum confidence of a rule as a percentage</td>
    <td valign="top">80</td></tr>
<tr><td valign="top"><tt>-e#</tt></td>
    <td>additional evaluation measure<br>
        frequent item sets:<br>
        <tt>x</tt>: no measure<br>
        <tt>b</tt>: binary logarithm of support quotient            (+)<br>
        association rules:<br>
        <tt>x</tt>: no measure<br>
        <tt>o</tt>: rule support (original def.: body & head)       (+)<br>
        <tt>c</tt>: rule confidence                                 (+)<br>
        <tt>d</tt>: absolute confidence difference to prior         (+)<br>
        <tt>l</tt>: lift value (confidence divided by prior)        (+)<br>
        <tt>a</tt>: absolute difference of lift value to 1          (+)<br>
        <tt>q</tt>: difference of lift quotient to 1                (+)<br>
        <tt>v</tt>: conviction (inverse lift for negated head)      (+)<br>
        <tt>e</tt>: absolute difference of conviction to 1          (+)<br>
        <tt>r</tt>: difference of conviction quotient to 1          (+)<br>
        <tt>z</tt>: certainty factor (relative confidence change)   (+)<br>
        <tt>n</tt>: normalized &chi;<sup>2</sup> measure            (+)<br>
        <tt>p</tt>: p-value from (unnormalized)
                    &chi;<sup>2</sup> measure       (-)<br>
        <tt>y</tt>: normalized &chi;<sup>2</sup> measure
                    with Yates' correction (+)<br>
        <tt>t</tt>: p-value from Yates-corrected
                    &chi;<sup>2</sup> measure       (-)<br>
        <tt>i</tt>: information difference to prior                 (+)<br>
        <tt>g</tt>: p-value from G statistic/information difference (-)<br>
        <tt>f</tt>: Fisher's exact test (table probability)         (-)<br>
        <tt>h</tt>: Fisher's exact test (&chi;<sup>2</sup> measure) (-)<br>
        <tt>m</tt>: Fisher's exact test (information gain)          (-)<br>
        <tt>s</tt>: Fisher's exact test (support)                   (-)<br>
        All measures for association rules are also applicable<br>
        to item sets and are then aggregated over all possible<br>
        association rules with a single item in the consequent.<br>
        The aggregation mode can be set with the option <tt>-a#</tt>.<br>
        Measures marked with (+) must meet or exceed the threshold,<br>
        measures marked with (-) must not exceed the threshold<br>
        in order for the rule or item set to be reported.</td>
    <td valign="top">x</td></tr>
<tr><td valign="top"><tt>-a#</tt></td>
    <td>aggregation mode for evaluation measure<br>
    <tt>x</tt>: no aggregation (use first value)<br>
    <tt>m</tt>: minimum of individual measure values<br>
    <tt>n</tt>: maximum of individual measure values<br>
    <tt>a</tt>: average of individual measure values<br>
    <tt>s</tt>: split item set into equal size subsets</td>
    <td valign="top">x</td></tr>
<tr><td valign="top"><tt>-d#</tt></td>
    <td>threshold for additional evaluation measure<br>
        (as a percentage)</td>
    <td valign="top">10</td></tr>
<tr><td valign="top"><tt>-q#</tt></td>
    <td>sort items w.r.t. their frequency<br>
        0: do not sort<br>
        1: ascending, -1: descending w.r.t. item frequency<br>
        2: ascending, -2: descending w.r.t. transaction size sum</td>
    <td valign="top">2</td></tr>
<tr><td valign="top"><tt>-p#</tt></td>
    <td>(minimum size for) pruning with evaluation<br>
       &lt;&nbsp;0: weak forward<br>
       &gt;&nbsp;0: strong forward<br>
       =&nbsp;0: backward pruning</td>
    <td>no pruning</td></tr>
<tr><td valign="top"><tt>-A#</tt></td>
    <td>variant of the Eclat algorithm to use<br>
        <tt>a</tt>: automatic choice based on data properties<br>
        <tt>e</tt>: transaction id lists intersection (basic)<br>
        <tt>i</tt>: transaction id lists intersection (improved)<br>
        <tt>b</tt>: transaction id lists represented as bit vectors<br>
        <tt>t</tt>: filtering with item occurrence table (standard)<br>
        <tt>s</tt>: filtering with item occurrence table (simplified)<br>
        <tt>r</tt>: transaction id range lists intersection<br>
        <tt>o</tt>: occurrence deliver from transaction lists<br>
        <tt>d</tt>: transaction id difference sets (diffsets/dEclat)</td>
    <td valign="top">a</td></tr>
<tr><td valign="top"><tt>-x</tt></td>
    <td>do not prune with perfect extensions</td>
    <td valign="top">prune</td></tr>
<tr><td valign="top"><tt>-l#</tt></td>
    <td>number of items for k-items machine<br>
        (only for algorithm variants i,r,o)</td>
    <td valign="top">16</td></tr>
<tr><td valign="top"><tt>-i</tt></td>
    <td>do not sort items w.r.t. conditional support<br>
        (only for algorithm variants i,b,t,d)</td>
    <td valign="top"></td></tr>
<tr><td valign="top"><tt>-y#</tt></td>
    <td>check extensions for closed/maximal sets<br>
        0: horizontal, &gt;0: vertical representation<br>
        (only with improved transaction id lists variant)</td>
    <td valign="top">repository</td></tr>
<tr><td valign="top"><tt>-u</tt></td>
    <td>do not use head union tail (hut) pruning<br>
        (only for maximal item sets, not with variant b)</td>
    <td valign="top">use hut</td></tr>
<tr><td valign="top"><tt>-F#:#..</tt></td>
    <td>support border for filtering item sets<br>
       (list of minimum support values, one per item set size,<br>
       starting at the minimum size, as given with option <tt>-m#</tt>)</td>
    <td valign="top">none</td></tr>
<tr><td valign="top"><tt>-R#</tt></td>
    <td>read an item selection from a file<br>
        parameter: file name</td>
    <td valign="top"></td></tr>
<tr><td valign="top"><tt>-P#</tt></td>
    <td>write a pattern spectrum to a file<br>
        parameter: file name</td>
    <td valign="top"></td></tr>
<tr><td valign="top"><tt>-Z</tt></td>
    <td>print item set statistics<br>
        (number of item sets per size)</td>
    <td valign="top"></td></tr>
<tr><td valign="top"><tt>-g</tt></td>
    <td>write output in scanable form<br>
        (quote certain characters)</td>
    <td valign="top"></td></tr>
<tr><td valign="top"><tt>-h#</tt></td>
    <td>record header  for output</td>
    <td valign="top">""</td></tr>
<tr><td valign="top"><tt>-k#</tt></td>
    <td>item separator for output</td>
    <td valign="top">" "</td></tr>
<tr><td valign="top"><tt>-I#</tt></td>
    <td>implication sign for association rules</td>
    <td valign="top">" "</td></tr>
<tr><td valign="top"><tt>-v#</tt></td>
    <td>output format for item set information<br>
        (changed to "<tt> (%a)</tt>" if parameter
        of <tt>-s</tt> is negative)</td>
    <td valign="top">"<tt> (%S)</tt>"<br>
                     "<tt> (%a)</tt>"</td></tr>
<tr><td valign="top"><tt>-w</tt></td>
    <td>transaction weight in last field</td>
    <td valign="top">only items</td></tr>
<tr><td valign="top"><tt>-r#</tt></td>
    <td>record/transaction separators</td>
    <td valign="top">"<tt>\n</tt>"</td></tr>
<tr><td valign="top"><tt>-f#</tt></td>
    <td>field/item separators</td>
    <td valign="top">"<tt> \t,</tt>"</td></tr>
<tr><td valign="top"><tt>-b#</tt></td>
    <td>blank characters</td>
    <td valign="top">"<tt> \t\r</tt>"</td></tr>
<tr><td valign="top"><tt>-C#</tt></td>
    <td>comment characters</td>
    <td valign="top">"<tt>#</tt>"</td></tr>
<tr><td valign="top"><tt>-T#</tt></td>
    <td>file to write transaction identifiers to<br>
        (only with algorithm variant i)</td>
    <td valign="top"></td></tr>
<tr><td valign="top"><tt>-!</tt></td>
    <td>print additional option information</td>
    <td valign="top"></td></tr>
</table>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="input">Input Format</a></h3>

<h4><a name="transin">Format of the Transactions File</a></h4>

<p>The transactions file has to be a (text) file structured by field
and record separators and blanks. Record separators, not surprisingly,
separate records, usually lines (since the default record separator
is the newline character), field separators separate fields, usually
words (since among the default field separators are the space and the
tabulator, but also the comma). Blanks are used to fill fields, for
example, to align them. In the transactions file each record must
contain one transaction, i.e. a list of item identifiers, which are
separated by field separators. An empty record is interpreted as an
empty transaction. That is, it is counted for the total number of
transactions, but does not count for the support of any item set other
than the empty set. A transaction may contain the same item multiple
times (that is, duplicate items do not raise an error), but this
multiplicity is disregarded by the Eclat program. It only considers
<i>whether</i> an item is contained in a transaction or not, <i>not</i>
how many times an item is contained in a transaction.</p>

<p>Example input files can be found in the directory <tt>eclat/ex</tt>
in the source package. These files are used in the following to
demonstrate how to use the command line options <tt>-r</tt>,
<tt>-f</tt>, <tt>-b</tt> and <tt>-w</tt>. In addition, there are
several conversion scripts (for Linux/Unix), with which different
common input formats can be converted into the format required by
the Eclat program.</p>

<p>In the file <tt>test1.tab</tt> transactions are separated by newline
characters (that is, each line of the file contains one transaction)
and the items of a transaction are separated by spaces. That is, the
file <tt>test1.tab</tt> looks like this:</p>

<p><tt>
a b c<br>
a d e<br>
b c d<br>
a b c d<br>
b c<br>
a b d<br>
d e<br>
a b c d<br>
c d e<br>
a b c
</tt></p>

<p>As can be seen, there are ten transactions over the item base
{a, b, c, d, e}, which contain between two and four items each.</p>

<p>The file <tt>test1.tab</tt> is in the standard input format and
hence it can be processed directly:</p>

<p><tt>eclat test1.tab test1.out</tt></p>

<p>Instead of spaces, tabulators may be used, and it is possible to mix
spaces and tabulators. Note, however, that multiple consecutive white
space characters (like multiple spaces or a space and a tabulator etc.)
are interpreted as a single field separator. The reason is that by
default spaces, tabulators and the carriage return character are
interpreted as blank characters, which are removed when reading
items. Hence only the first white space character after an item is
interpreted as a field separator, all following white space characters
are interpreted as blanks.</p>

<p>Note also that commas are among the default field separators as well.
That is, if the file <tt>test1.tab</tt> looked like this:</p>

<p><tt>
a,b,c<br>
a,d,e<br>
b,c,d<br>
a,b,c,d<br>
b,c<br>
a,b,d<br>
d,e<br>
a,b,c,d<br>
c,d,e<br>
a,b,c
</tt></p>

<p>it could still be processed directly with the command stated
above. You may also mix spaces, tabulators and commas.</p>

<p>Unfortunately, though, the fact that commas are interpreted as field
separators does not necessarily mean that CSV-files (where CSV stands
for "comma separated values"), as they can be written by programs like
Microsoft Excel, can be processed directly. The reason is that in a
CSV-file all lines contain the same number of fields. That is, in
CSV-format, the above input file would look like this (file
<tt>test1.csv</tt> in directory <tt>eclat/ex</tt>):</p>

<p><tt>
a,b,c,<br>
a,d,e,<br>
b,c,d,<br>
a,b,c,d<br>
b,c,,<br>
a,b,d,<br>
d,e,,<br>
a,b,c,d<br>
c,d,e,<br>
a,b,c,
</tt></p>

<p>Note the single and double commas at the end of most lines, which
separate empty fields (as these transactions have fewer items than
the longest transaction). While a single comma at the end of a line
does not cause any problems and is simply ignored, two or more commas
lead to an error message "<tt>item expected</tt>", because an item may
not be an empty string. This can be fixed by declaring the comma a
blank character (option <tt>-b</tt>). That is, the CSV-file can be
processed with:</p>

<p><tt>eclat -b, test1.csv test1.out</tt></p>

<p>Note, however, that the characters given with the option <tt>-b</tt>
replace the default blank characters. So if you still need spaces to be
interpreted as blanks, they have to be specified as well:</p>

<p><tt>eclat -b" ," test1.csv test1.out</tt></p>

<p>In the file <tt>test2.tab</tt> the same transactions can be found,
but several different field separators are used:</p>

<p><tt>
a,b,c<br>
a,d,e<br>
b.c.d<br>
a,b,c,d<br>
b:c<br>
a,b,d<br>
d,e<br>
a,b,c,d<br>
c;d;e<br>
a,b,c
</tt></p>

<p>The file <tt>test2.tab</tt> can be processed by declaring different
field separators with the option <tt>-f</tt>:</p>

<p><tt>eclat -f",.;:" -l test2.tab test2.out</tt></p>

<p>The file <tt>test3.tab</tt> has basically the same format as the
file <tt>test1.tab</tt>, with the only difference that the last fields
of each record states an (integer) transaction weight/multiplicity.</p>

<p><tt>
a b c 2<br>
a d e 1<br>
b c d 1<br>
a b c d 2<br>
b c 1<br>
a b d 1<br>
d e 1<br>
c d e 1
</tt></p>

<p>This allows us to combine transactions, so that <tt>test2.tab</tt>
has only 8 lines, while <tt>test1.tab</tt> has 10 lines, because the
transactions <tt>a b c</tt> and <tt>a b c d</tt> occur twice. In order
to instruct the Eclat program to interpret the last field of each record
as such a weight/multiplicity, is has to be invoked with the option
<tt>-w</tt>:</p>

<p><tt>eclat -w test3.tab test3.out</tt></p>

<p>The files <tt>test4.tab</tt> to <tt>test6.tab</tt> are in formats
that may be common, but which cannot be processed directly with the
Eclat program.</p>

<p>In the file <tt>test4.tab</tt> each line contains a transaction
identifier and an item, separated by a space (not shown because of
the large number of lines). This file can be converted (on Linux/Unix
systems) into the standard input format with the script
<tt>tid2set</tt>, i.e., with</p>

<p><tt>tid2set test4.tab x.tab</tt></p>

<p>Note that this script sorts the input file (here: <tt>test4.tab</tt>)
w.r.t. the transaction identifier, so that items belonging to the same
transaction occupy consecutive lines/records. That is, the input need
not already be sorted by transaction identifier, rather the script does
this to make sure that the conversion works.</p>

<p>In the file <tt>test5.tab</tt> the first line states the item names
and the following lines contain flags <tt>T</tt> (true) and <tt>F</tt>
(false) depending on whether the item is contained in the transaction
represented by the line or not:</p>

<p><tt>
a b c d e<br>
T T T F F<br>
T F F T T<br>
F T T T F<br>
T T T T F<br>
F T T F F<br>
T T F T F<br>
F F F T T<br>
T T T T F<br>
F F T T T<br>
T T T F F
</tt></p>

<p>This format can be converted (on Linux/Unix systems) into the
standard input format with the script <tt>flg2set</tt>, i.e., with</p>

<p><tt>flg2set test5.tab x.tab</tt></p>

<p>This script interprets <tt>T</tt>, <tt>t</tt>, and <tt>1</tt> as
"true", that is, as indicators that the item corresponding to the
column is contained in the transaction corresponding to the row,
and any other entry as "false" (the item is not contained in the
transaction).</p>

<p>In the file <tt>test6.tab</tt> there is one item per line and
transactions are separated by blank lines (not shown here because of
the large number of lines). This format can be converted (on Linux/Unix
systems) into the standard input format with the script
<tt>row2set</tt>, i.e., with:</p>

<p><tt>row2set test6.tab x.tab</tt></p>

<p>Note that the file <tt>test6.tab</tt> could be processed directly
if the transactions were not separated by a mere empty line (that is,
two newline characters following each other), but if the empty line
contained a special character, for example <tt>%</tt>. In this case
the file can be processed directly with</p>

<p><tt>eclat -r"%" -f"\n" -b"\n" test6.tab x.tab</tt></p>

<p>The additional scripts <tt>tab2set</tt> and <tt>hdr2set</tt> convert
tables with column numbers or column names into a format appropriate
for the Eclat program. They are invoked in the same way as all other
scripts discussed above, i.e., with</p>

<p><tt>tab2set a.tab b.tab</tt></p>

<p>or</p>

<p><tt>hdr2set a.tab b.tab</tt></p>

<p>where <tt>a.tab</tt> is the name of the input file and <tt>b.tab</tt>
the name of the output file. The script <tt>tab2set</tt> replaces each
table entry "x" of the input file by "Xi=x", where i is the column number
(starting with 1).</p>

<p>The script <tt>hdr2set</tt> reads the variable names from the first
line of the input file and then replaces each table entry "x" by "X=x",
where "X" is the variable name that was found in the corresponding
column of the first line. These scripts are handy if you want to
process tabular data by treating each table row as a transaction.</p>

<p>Note that any input may also be read from standard input and any
output may be sent to standard output, simply by specifying a
'<tt>-</tt>' or an empty string <tt>""</tt> instead of a filename.
For example (on a Linux/Unix system)</p>

<p><tt>cat test1.tab | eclat - -</tt></p>

<p>reads the transactions from standard input (where they are fed by
the cat command) and writes the found frequent item sets directly to
the terminal. They may be piped to any other program or script, since
all other messages of the Eclat program are written to standard
error.</p>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<hr>

<h4><a name="selin">Format of the Item Selection File</a></h4>

<p>In addition to an input file with the transactions and an output
file for the found item sets, an item selection file may be passed
to the Eclat program with the option <tt>-R</tt>. This file lists a
selection of items that are to be included in the search, while any
items not listed in this file are to be ignored. It can be seen as
a specification of the item base for the search.</p>

<p>The item selection file has to be a (text) file structured by the
same field and record separators and blanks as the transactions file.
Items may be listed in a single record or in multiple records; it does
not matter in which record an item occurs. All that matters is whether
an item occurs in the item selection file (then it is included in the
search) or not (then it is ignored).</p>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="output">Output Format</a></h3>

<p>The output format for item sets is fairly flexible. Especially
the output of the additional information about item sets (support,
additional evaluation) can be formatted freely.</p>

<!-- =============================================================== -->
<hr>

<h4><a name="setout">Format of Frequent Item Sets</a></h4>

<p>Each line of the output file contains one item set in the format</p>

<p><tt>A&nbsp;B&nbsp;C&nbsp;[...]&nbsp;&lt;add.&nbsp;info&gt;</tt></p>

<p>where A, B and C are item identifiers, and
<tt>&lt;add.&nbsp;info&gt;</tt>
is determined by the additional information output format (option
<tt>-v</tt>). The item separator may be changed with the option
<tt>-k</tt>. For example,</p>

<p><tt>eclat -k, test1.tab test.out</tt></p>

<p>produces output in the format</p>

<p><tt>A,B,C,[...]&nbsp;&lt;add.&nbsp;info&gt;</tt></p>

<p>Each output line may be preceded by a string that is specified
with the option <tt>-h</tt> (record header for output).</p>

<p>The output format for the additional rule information can be any
string with the following special format symbols (similar to the
style of the special format symbols of the <tt>printf</tt> function
in the programming language C):</p>

<table border=0 cellpadding=0 cellspacing=0>
<tr><td>%%</td><td style="width:16px"></td>
    <td>a percent sign</td></tr>
<tr><td>%i</td><td></td>
    <td>number of items (item set size)</td></tr>
<tr><td>%a</td><td></td>
    <td>absolute item set support</td></tr>
<tr><td>%s</td><td></td>
    <td>relative item set support as a fraction</td></tr>
<tr><td>%S</td><td></td>
    <td>relative item set support as a percentage</td></tr>
<tr><td>%e</td><td></td>
    <td>additional evaluation measure</td></tr>
<tr><td>%E</td><td></td>
    <td>additional evaluation measure as a percentage</td></tr>
</table>

<p>All format specifiers can be extended by an integer number between
the percent sign and the defining character, which specifies the number
of decimal digits to be printed (expect those that refer to integer
numbers, like the number of items and the absolute support, for which
such a number of digits is ignored). If no such number is given,
(up to) six significant digits are reported.</p>

<p>The default additional information output format is for item sets
"<tt>  (%S)</tt>". That is, the relative support of the item set is
printed with (up to) six significant digits, enclosed in parentheses.
Two spaces separate the additional information from the last item
in the set. The default format is automatically changed to
"<tt>  (%a)</tt>" if the minimum support (option <tt>-s</tt>)
is given as a negative number (absolute support), so that the output
is consistent with the support threshold.</p>

<!-- =============================================================== -->
<hr>

<h4><a name="pspout">Format of a Pattern Spectrum</a></h4>

<p>A pattern spectrum collects the number of found frequent item sets
sub-divided by the size and the support of the item sets. Pattern
spectra (together with surrogate data/randomization methods) can be
useful to determine the statistical significance of found frequent
item sets. Details can be found in the papers
<a href="#Picado-Muino_et_al_2013">[Picado-Muino <i>et al.</i> 2013]</a>
and <a href="#Torre_et_al_2013">[Torre <i>et al.</i> 2013]</a>.</p>

<p>My Eclat implementation can be instructed to collect and write a
pattern spectrum with the option <tt>-P</tt>, which takes the name
of the file to which the patterns spectrum is to be written as a
parameter.</p>

<p>A pattern spectrum is written as a list of (size, support, count)
triplets. The output file is a simple text file that contains one
triplet per line, with the three numbers separated by spaces.
For example, for the input file <tt>test1.tab</tt> (see
<a href="#transin">this section</a>) the pattern spectrum is
(with default option settings):</p>

<p><tt>
1 3 1<br>
1 6 1<br>
1 7 3<br>
2 1 2<br>
2 3 1<br>
2 4 4<br>
2 5 1<br>
2 6 1<br>
3 1 2<br>
3 2 1<br>
3 3 2<br>
3 4 1<br>
4 2 1
</tt></p>

<p>The first column contains the different sizes of item sets, the
second column the difference support values, and the third column
the number of item sets found for the corresponding (size, support)
combination. For example, the sixth row indicates that there are
four frequent item sets with two items and support 4. Note that in
a pattern spectrum the support is always given as absolute support,
that is, as a number of transactions.</p>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="license">License</a></h3>

<p>(MIT license, or more precisely Expat License;
to be found in the file <tt>mit-license.txt</tt> in the directory
<tt>eclat/doc</tt> in the source package of the program, see also
<a href="http://www.opensource.org/licenses/MIT">opensource.org</a> and
<a href="http://en.wikipedia.org/wiki/MIT_license">wikipedia.org</a>)
</p>

<p>&copy; 2002-2016 Christian Borgelt</p>

<p>Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and/or sell copies of the Software,
and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:</p>

<p>The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.</p>

<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="download">Download</a></h3>

<p><a href="http://www.borgelt.net/eclat.html">
Download page</a> with most recent version.</p>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="contact">Contact</a></h3>

<table border=0 cellpadding=0 cellspacing=0>
<tr><td valign="top">E-mail:</td><td style="width:10px"></td>
    <td><a href="mailto:christian@borgelt.net">
        christian@borgelt.net</a><br>
<tr><td valign="top">Website:</td><td</td>
    <td><a href="http://www.borgelt.net/">
        www.borgelt.net</a><br>
</table>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="refs">References</a></h3>

<p>An overview of frequent item set mining covering Eclat and many
other algorithms can be found in this survey paper:</p>

<ul style="list-style-type:disc">
<li><a name="Borgelt_2012"></a><b>Frequent Item Set Mining</b><br>
    Christian Borgelt<br>
    <i>Wiley Interdisciplinary Reviews:
    Data Mining and Knowledge Discovery</i> 2(6):437-456.<br>
    J.&nbsp;Wiley&nbsp;&amp;&nbsp;Sons, Chichester, United Kingdom 2012<br>
    <a href="http://dx.doi.org/10.1002/widm.1074">doi:10.1002/widm.1074</a>
    <a href="http://onlinelibrary.wiley.com/doi/10.1002/widm.1074/abstract">wiley.com</a><br>
    (20&nbsp;pages)</li>
</ul>

<p>A description of some implementation aspects can be found in
the following paper, although, due to a complete redesign in
version 3.0, it does not fit the current program state anymore:</p>

<ul style="list-style-type:disc">
<li><a name="Borgelt_2003"></a><b>Efficient Implementations
    of Apriori and Eclat</b><br>
    Christian Borgelt.<br>
    <i>Workshop of Frequent Item Set Mining Implementations</i>
    (FIMI 2003, Melbourne, FL, USA).<br>
    (9 pages)
    <a href="http://www.borgelt.net/papers/fimi_03.pdf">
    fimi_03.pdf</a> (304 kb)
    <a href="http://www.borgelt.net/papers/fimi_03.ps.gz">
    fimi_03.ps.gz</a> (197 kb)</li>
</ul>

<p>The use of pattern spectra to evaluate the statistical significance
of found frequent item sets is explained in these papers:</p>

<ul style="list-style-type:disc">
<li><a name="Picado-Muino_et_al_2013"></a><b>Finding Neural Assemblies
    with Frequent Item Set Mining</b><br>
    David Picado-Mui&ntilde;o, Christian Borgelt, Denise Berger,
    George Gerstein, and Sonja Gr&uuml;n<br>
    <i>Frontiers in Neuroinformatics</i> 7:article&nbsp;9<br>
    Frontiers Media, Lausanne, Switzerland 2013<br>
    <a href="http://dx.doi.org/10.3389/fninf.2013.00009">doi:10.3389/fninf.2013.00009</a>
    <a href="http://www.frontiersin.org/Neuroinformatics/10.3389/fninf.2013.00009/abstract">frontiersin.org</a><br>
    <a href="papers/accfim.pdf">accfim.pdf</a> (1797 kb)
    <a href="papers/accfim.ps.gz">accfim.ps.gz</a> (772 kb)
    (14&nbsp;pages)</li>
<li><a name="Torre_et_al_2013"></a><b>Statistical Evaluation
    of Synchronous Spike Patterns extracted by Frequent Item
    Set Mining</b><br>
    Emiliano Torre, David Picado-Mui&ntilde;o, Michael Denker,
    Christian Borgelt, and Sonja Gr&uuml;n<br>
    <i>Frontiers in Computational Neuroscience</i>,
    7:article&nbsp;132<br>
    Frontiers Media, Lausanne, Switzerland 2013<br>
    <a href="http://dx.doi.org/10.3389/fninf.2013.00132">doi:10.3389/fninf.2013.00132</a>
    <a href="http://www.frontiersin.org/Computational_Neuroscience/10.3389/fncom.2013.00132/abstract">frontiersin.org</a><br>
    (13&nbsp;pages)</li>
</ul>

<p>Other references for the Eclat and LCM algorithms include:</p>

<ul style="list-style-type:disc">
<li><a name="Zaki_et_al_1997"></a><b>New Algorithms
    for Fast Discovery of Association Rules</b><br>
    M.J.&nbsp;Zaki, S.&nbsp;Parthasarathy, M.&nbsp;Ogihara,
    and W.&nbsp;Li<br>
    <i>Proc. 3rd ACM SIGKDD Int. Conf. on Knowledge Discovery
    and Data Mining (KDD'97, Newport Beach, CA)</i>, 283-296<br>
    AAAI Press, Menlo Park, CA, USA 1997</li>
<li><a name="Zaki_and_Gouda_2003"></a><b>Fast
    Vertical Mining Using Diffsets</b><br>
    M.J.&nbsp;Zaki and K.&nbsp;Gouda<br>
    <i>Proc. 9th ACM SIGKDD Int. Conf. on Knowledge Discovery
    and Data Mining (KDD 2003, Washington, DC)</i>, 326-335<br>
    ACM Press, New York, NY, USA 2003</li>
<li><a name="Uno_et_al_2003"></a><b>LCM:
    An Efficient Algorithm for Enumerating
    Frequent Closed Item Sets.</b><br>
    T. Uno, T.&nbsp;Asai, Y.&nbsp;Uchida, and H.&nbsp;Arimura.<br>
    <i>Proc. Workshop on Frequent Item Set Mining Implementations
    (FIMI&nbsp;2003, Melbourne, FL).</i><br>
    <a href="http://ceur-ws.org/Vol-90/">CEUR
    Workshop Proceedings&nbsp;90</a>,
    TU Aachen, Germany 2003</li>
<li><a name="Uno_et_al_2004"></a><b>LCM ver.&nbsp;2:
    Efficient Mining Algorithms
    for Frequent/Closed/Maximal Itemsets.</b><br>
    T.&nbsp;Uno, M.&nbsp;Kiyomi and H.&nbsp;Arimura.<br>
    <i>Proc. Workshop Frequent Item Set Mining Implementations
    (FIMI&nbsp;2004, Brighton, UK).</i><br>
    <a href="http://ceur-ws.org/Vol-126/">CEUR
    Workshop Proceedings&nbsp;126</a>,
    TU Aachen, Germany 2004</li>
<li><a name="Uno_et_al_2005"></a><b>LCM ver.&nbsp;3:
    Collaboration of Array, Bitmap and Prefix Tree
    for Frequent Itemset Mining.</b><br>
    T.&nbsp;Uno, M.&nbsp;Kiyomi, and H.&nbsp;Arimura.<br>
    <i>Proc. 1st Open Source Data Mining Workshop
    on Frequent Pattern Mining Implementations
    (OSDM&nbsp;2005, Chicago, IL)</i>, 77-86.<br>
    ACM Press, New York, NY, USA 2005</li>
</ul>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<address>&copy; 2002-2016
<a href="mailto:christian@borgelt.net">Christian Borgelt</a>
</address>
</body>
</html>
